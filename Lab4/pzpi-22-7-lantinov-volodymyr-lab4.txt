Міністерство освіти і науки України Харківський національний університет радіоелектроніки

Кафедра програмної інженерії

Звіт
З лабораторної роботи №4
З дисципліни «Архітектура програмного забезпечення»
на тему: «РОЗРОБКА МОБІЛЬНОГО КЛІЄНТА СИСТЕМИ»

Виконавець:
ст. гр. ПЗПІ-22-7							Лантінов Володимир.

Перевірив:
ст. викладач каф. ПІ						Сокорчук І. П.



















Харків 2025
 
1	ІСТОРІЯ ЗМІН


№	Дата	Версія звіту	Опис	змін	та
виправлень
1	23.05.2025	0.1	Створено структуру звіту. Визначено завдання	на
лабораторну роботу
2	26.05.2025	0.1	Описано хід роботи, додаток А, додаток Б, додаток В. Сформульовано
висновок роботи

2	ЗАВДАННЯ

Метою даного лабораторного заняття є розробка мобільної / mobile частини програмної системи.

3	ОПИС ВИКОНАНОЇ РОБОТИ


До виконаної роботи було створено відеозвіт, посилання на який наведено у додатку А.
У рамках виконання завдання було розроблено клієнтську частину мобільного додатку для платформи Android з використанням мови програмування Kotlin, що забезпечило створення інтерактивного та функціонального інтерфейсу для системи мониторингу транспортних засобів. Робота розпочалася з ініціалізації проєкту в Android Studio, під час якої було налаштовано базову навігацію через Jetpack Navigation Component та основні залежності, такі як Retrofit для роботи з REST API, OkHttp для MQTT комунікації та ViewModels з StateFlow для управління станом додатку.
Надалі було створено набір екранів, таких як головний Dashboard з переліком транспортних засобів, екрани авторизації та реєстрації, а також екрани для real-time мониторингу телеметричних даних, управління алертами, перегляду аналітики з AI рекомендаціями та адміністрування системи, що разом сформували цілісну IoT платформу для взаємодії користувача з транспортними засобами.
Основна увага під час розробки була зосереджена на забезпеченні зручності та інтуїтивності інтерфейсу, а також на реалізації ключових функціональних можливостей мониторингу. Для цього використано RecyclerView з DiffUtil для ефективного відображення списків телеметричних даних, кастомні компоненти для візуалізації показників двигуна, рівня палива та геолокації. Окремо реалізовано функціонал віддаленого управління транспортними засобами через MQTT протокол, систему багаторівневих алертів та інтеграцію з Google Gemini AI для персоналізованих рекомендацій по обслуговуванню. Для забезпечення коректної роботи використано архітектуру MVVM з ViewModels та StateFlow, що дало змогу ефективно керувати real-time даними між екранами.
Для забезпечення візуальної привабливості та зручності використання було розроблено стилі з використанням Material Design 3 з кольоровою палітрою проекту (#403D58, #878E88, #EFCEFA, #D8F1A0, #FE5E41). Стилі були створені з акцентом на сучасний дизайн, адаптивність для різних розмірів екранів, підтримку темної теми та єдність стилістичного оформлення з веб-платформою. У результаті виконаної роботи було створено функціональний мобільний додаток із зручним інтерфейсом для IoT мониторингу, підтримкою двомовності (англійська/українська) та можливостями управління транспортними засобами в реальному часі, що відповідає поставленим вимогам системи Vehicle Management System.
Деякий код застосунку наведено у додатку Б.

Прийняті інженерні рішення для мобільного застосунку
Під час розробки мобільного застосунку системи мониторингу та управління транспортними засобами було прийнято низку ключових технічних та архітектурних рішень, що забезпечили стабільність, модульність та потенціал для масштабування IoT платформи.

1. Технологічний стек та мова програмування
Kotlin як основна мова розробки: Застосунок розроблено мовою Kotlin, що є офіційною та рекомендованою мовою для Android-розробки. Kotlin забезпечує лаконічний, безпечний та виразний синтаксис з повною сумісністю з Java, що сприяє написанню чистого коду та зменшенню кількості типових помилок при роботі з IoT даними та real-time операціями.
Material Design 3: Застосовано найновішу дизайн-систему Google для створення сучасного та інтуїтивного користувацького інтерфейсу з підтримкою динамічних кольорів та адаптивних компонентів.

2. Архітектурні патерни та структура UI
MVVM архітектурний патерн: Реалізовано Model-View-ViewModel архітектуру з використанням Android Architecture Components для забезпечення розділення відповідальностей та lifecycle-aware компонентів.
Фрагментна структура UI: Користувацький інтерфейс побудовано на основі фрагментів, що включає:
•	DashboardFragment - головна панель з переліком транспортних засобів
•	VehicleDetailFragment - детальна інформація про ТЗ з real-time даними
•	AlertsFragment - система сповіщень та алертів
•	ProfileFragment - профіль користувача та налаштування
•	VehicleRegistrationFragment - реєстрація нових транспортних засобів
Такий підхід підвищує гнучкість навігації, спрощує керування життєвим циклом UI та забезпечує легкість підтримки модульних компонентів IoT платформи.

3. Мережева взаємодія та API інтеграція
Retrofit для HTTP комунікації: Для взаємодії з серверною частиною використано бібліотеку Retrofit з наступними API інтерфейсами:
•	AuthAPI - аутентифікація та авторизація користувачів
•	VehicleAPI - управління транспортними засобами та отримання телеметричних даних
•	AlertAPI - система сповіщень про критичні події
•	AnalyticsAPI - аналітичні дані та звіти
OkHttp інтерсепторы: Реалізовано автоматичне додавання JWT токенів та обробку помилок мережевих запитів з централізованою конфігурацією в NetworkModule.

4. Багатошарова архітектура
Шар даних (data): Містить логіку отримання та обробки даних IoT платформи:
•	API інтерфейси - REST endpoints для всіх операцій системи
•	Моделі даних - Vehicle, VehicleData, Alert, User з підтримкою Kotlin data classes
•	Репозиторії - VehicleRepository, AuthRepository для абстракції джерел даних
•	Мережева конфігурація - централізована настройка HTTP клієнта
Шар презентації (ui): Відповідає за відображення даних та взаємодію з користувачем:
•	Activities - MainActivity з Navigation Component
•	Fragments - модульні екрани для різних функцій системи
•	Adapters - VehicleListAdapter, AlertAdapter для відображення списків
Шар бізнес-логіки (viewmodels): ViewModel класи з StateFlow для reactive programming:
•	VehicleViewModel - управління станом транспортних засобів
•	AuthViewModel - логіка аутентифікації
•	AlertViewModel - обробка системних сповіщень

5. Real-time функціональність та IoT інтеграція
MQTT підтримка: Інтеграція з MQTT протоколом для отримання real-time даних від IoT пристроїв транспортних засобів, включаючи:
•	Температуру двигуна
•	Рівень палива
•	Швидкість руху
•	GPS координати
•	Статус двигуна (увімкнено/вимкнено)
Команди управління: Реалізовано відправку команд на IoT пристрої:
•	Запуск/зупинка двигуна
•	Включення/виключення аварійного режиму
•	Кастомні команди управління

6. Система безпеки та багатокористувацький доступ
JWT аутентифікація: Використання JSON Web Tokens для безпечного доступу до ресурсів з автоматичним оновленням токенів та обробкою сесій.
Роле-орієнтований доступ: Підтримка різних рівнів доступу:
•	Власники пристроїв з повними правами
•	Користувачі зі спільним доступом
•	Адміністратори системи
Валідація даних: Комплексна перевірка вхідних даних на клієнтській стороні для запобігання некоректним запитам до IoT платформи.

7. Локалізація та користувацький досвід
Двомовний інтерфейс: Повна підтримка української та англійської мов з динамічним перемиканням без перезапуску додатку.
Адаптивний дизайн: Responsive UI для різних розмірів екранів з оптимізацією для планшетів та смартфонів.
Офлайн функціональність: Кешування критично важливих даних для роботи без інтернет з'єднання.

8. Масштабованість та розширюваність
Модульна архітектура: Чітке розділення на компоненти дозволяє легко додавати:
•	Нові типи IoT пристроїв
•	Додаткові сенсори та телеметричні дані
•	Розширення функціоналу аналітики
•	Інтеграцію з іншими системами моніторингу
Dependency Injection: Використання Dagger/Hilt для управління залежностями та спрощення тестування компонентів системи.
Застосовані технічні та архітектурні рішення створили надійну основу для мобільного клієнта IoT платформи мониторингу транспортних засобів, забезпечивши високу продуктивність, безпеку та зручність для подальшого розвитку системи.

Опис взаємодії компонентів мобільного застосунку
Мобільний застосунок системи мониторингу та управління транспортними засобами побудований на модульній архітектурі, де кожен компонент виконує окрему логічну функцію IoT платформи. Взаємодія між внутрішніми компонентами та із зовнішніми сервісами реалізована через чітко визначені механізми, що забезпечують стабільність та масштабованість системи real-time моніторингу.
Взаємодія між компонентами застосунку
MainActivity як архітектурний центр: Головна активність виступає як контейнер для всіх компонентів системи мониторингу, забезпечуючи централізоване управління навігацією та життєвим циклом фрагментів. Інтегрована з Android Navigation Component для seamless переходів між екранами IoT платформи.
Система фрагментів: Основні екрани застосунку реалізовані як автономні фрагменти з чітко визначеними обов'язками:
•	DashboardFragment - відображає загальний огляд усіх транспортних засобів користувача з real-time статусами
•	VehicleDetailFragment - детальна інформація про конкретний транспортний засіб з телеметричними даними
•	AlertsFragment - централізована система сповіщень про критичні події
•	VehicleRegistrationFragment - реєстрація нових IoT пристроїв у системі
•	ProfileFragment - управління профілем користувача та налаштуваннями доступу
Механізми передачі даних: Комунікація між фрагментами здійснюється через:
•	SafeArgs - типобезпечна передача параметрів (deviceId, vehicleData)
•	SharedViewModel - спільний стан для синхронізації даних між екранами
•	Bundle arguments - передача конфігурацій та ідентифікаторів транспортних засобів
Адаптери для списків: Спеціалізовані адаптери забезпечують ефективне відображення динамічних даних:
•	VehicleListAdapter - список транспортних засобів з real-time оновленнями
•	AlertAdapter - відображення системних сповіщень з різними рівнями важливості
•	VehicleDataAdapter - історичні дані телеметрії з графічним представленням
Взаємодія з backend системою
RESTful API інтеграція: Комунікація з серверною частиною IoT платформи здійснюється через Retrofit з підтримкою асинхронних операцій:
interface VehicleAPI {
    @GET("/api/vehicles")
    suspend fun getVehicles(): Response<List<Vehicle>>
    
    @POST("/api/vehicles/{deviceId}/command")
    suspend fun sendCommand(@Path("deviceId") id: String, @Body command: Command)
    
    @GET("/api/vehicles/{deviceId}/data")
    suspend fun getVehicleData(@Path("deviceId") id: String): Response<VehicleDataResponse>
}
API інтерфейси за функціональними доменами:
•	AuthAPI - аутентифікація з JWT токенами та управління сесіями
•	VehicleAPI - CRUD операції з транспортними засобами та відправка команд управління
•	AlertAPI - система сповіщень з фільтрацією за рівнями важливості
•	AnalyticsAPI - отримання аналітичних звітів та статистики використання
Моделі даних та серіалізація: JSON дані автоматично мапляються у Kotlin data classes з підтримкою nested структур:
data class Vehicle(
    val deviceId: String,
    val name: String,
    val model: String,
    val latestData: VehicleData?,
    val status: VehicleStatus,
    val lastSeen: String
)

data class VehicleData(
    val temperature: Double,
    val fuelLevel: Double,
    val speed: Double,
    val isEngineRunning: Boolean,
    val emergencyMode: Boolean,
    val location: GeoLocation,
    val timestamp: String
)
MQTT інтеграція для real-time даних
Асинхронна телеметрія: Мобільний застосунок підключається до MQTT брокера для отримання real-time даних від IoT пристроїв транспортних засобів:
•	Температура двигуна - моніторинг перегріву з критичними алертами
•	Рівень палива - відстеження споживання та попередження про низький рівень
•	GPS координати - відстеження маршруту та геолокації
•	Статус двигуна - моніторинг увімкнення/вимкнення
•	Аварійний режим - критичні сповіщення про небезпечні ситуації
Команди управління: Двостороння комунікація дозволяє відправляти команди на IoT пристрої:
•	Віддалений запуск/зупинка двигуна
•	Активація/деактивація аварійного режиму
•	Кастомні команди діагностики
Архітектура репозиторіїв
Абстракція джерел даних: Репозиторії забезпечують єдиний інтерфейс для доступу до різних джерел даних IoT системи:
class VehicleRepository @Inject constructor(
    private val vehicleAPI: VehicleAPI,
    private val localCache: VehicleCache,
    private val mqttClient: MQTTClient
) {
    suspend fun getVehicles(): Flow<List<Vehicle>> = flow {
        emit(localCache.getVehicles())
        emit(vehicleAPI.getVehicles().body() ?: emptyList())
    }
    
    suspend fun sendCommand(deviceId: String, command: Command) {
        vehicleAPI.sendCommand(deviceId, command)
        mqttClient.publishCommand(deviceId, command)
    }
}
Кешування та офлайн підтримка:
•	Room Database - локальне збереження критично важливих даних
•	DataStore - збереження користувацьких налаштувань та токенів
•	Memory Cache - тимчасове кешування для швидкого доступу
Обробка помилок та стабільність
Централізована обробка помилок:
•	Автоматичне повторне підключення до MQTT при втраті з'єднання
•	Fallback механізми при недоступності REST API
•	Graceful degradation функціональності в офлайн режимі
Lifecycle-aware компоненти: Всі компоненти адаптовані до Android lifecycle для запобігання memory leaks та забезпечення стабільної роботи IoT з'єднань.
Така архітектура забезпечує надійну, масштабовану та ефективну взаємодію всіх компонентів мобільного застосунку системи мониторингу транспортних засобів з підтримкою real-time операцій та стабільною роботою в умовах нестабільного мережевого з'єднання

Взаємодія з IoT пристроями транспортних засобів (через сервер)
Опосередкована архітектура взаємодії: Мобільний застосунок системи мониторингу транспортних засобів взаємодіє з IoT пристроями опосередковано – через централізований backend-сервер, що забезпечує безпечну та стабільну комунікацію з розподіленою мережею транспортних засобів.
Відправка команд управління: Застосунок може надсилати команди керування на сервер для подальшої передачі IoT пристроям транспортних засобів:
•	Реєстрація нових транспортних засобів - через спеціалізовані UI-екрани з валідацією deviceId та конфігурацією доступу
•	Команди управління двигуном - віддалений запуск/зупинка через безпечні API-запити
•	Активація аварійного режиму - критичні команди з підтвердженням та логуванням
•	Налаштування параметрів моніторингу - конфігурація частоти передачі телеметричних даних
// Приклад відправки команди через VehicleAPI
suspend fun sendEngineCommand(deviceId: String, action: EngineAction) {
    val command = VehicleCommand(
        action = action.name,
        timestamp = System.currentTimeMillis(),
        userId = getCurrentUserId()
    )
    vehicleAPI.sendCommand(deviceId, command)
}
Отримання телеметричних даних: Застосунок отримує real-time дані від сервера про стан транспортних засобів через спеціалізовані API інтерфейси:
•	VehicleDataAPI - телеметричні дані (температура двигуна, рівень палива, швидкість, GPS координати)
•	AlertAPI - критичні сповіщення про несправності, перегрів двигуна, низький рівень палива
•	AnalyticsAPI - історичні дані, статистика використання, звіти про поїздки
data class VehicleTelemetry(
    val deviceId: String,
    val engineTemperature: Double,
    val fuelLevel: Double,
    val currentSpeed: Double,
    val isEngineRunning: Boolean,
    val emergencyMode: Boolean,
    val gpsLocation: GeoLocation,
    val batteryVoltage: Double,
    val lastUpdateTime: String
)
MQTT інтеграція для real-time комунікації: Сервер виступає як MQTT брокер, забезпечуючи швидку двосторонню комунікацію:
•	Підписка на топіки даних - /vehicles/{deviceId}/telemetry для отримання актуальних показників
•	Публікація команд - /vehicles/{deviceId}/commands для віддаленого управління
•	Система алертів - /vehicles/{deviceId}/alerts для критичних сповіщень
Багаторівнева безпека взаємодії:
•	JWT аутентифікація - всі запити захищені токенами доступу
•	Валідація прав доступу - перевірка власності транспортного засобу на серверному рівні
•	Шифрування команд - критичні команди управління додатково шифруються
•	Аудит операцій - логування всіх команд управління з timestamp та userId
Обробка мережевих збоїв та офлайн режим:
class VehicleRepository {
    suspend fun syncVehicleData(): Flow<SyncResult> = flow {
        try {
            val onlineData = vehicleAPI.getVehicleData()
            localCache.updateVehicleData(onlineData)
            emit(SyncResult.Success(onlineData))
        } catch (exception: NetworkException) {
            val cachedData = localCache.getVehicleData()
            emit(SyncResult.Cached(cachedData))
        }
    }
}
Масштабованість взаємодії: Архітектура дозволяє легко масштабувати систему для підтримки:
•	Великої кількості транспортних засобів одного користувача
•	Різних типів IoT пристроїв (легкові авто, вантажівки, мотоцикли)
•	Додаткових сенсорів (тиск в шинах, рівень масла, діагностика двигуна)
•	Інтеграції з іншими IoT платформами та сервісами
Таким чином, backend-сервер виступає як централізований посередник, обробляючи комунікацію з розподіленою мережею IoT пристроїв транспортних засобів та надаючи мобільному застосунку необхідні дані та функціональність для комплексного моніторингу, аналітики та віддаленого управління. Така архітектура забезпечує ефективний real-time моніторинг флоту транспортних засобів, роблячи систему зрозумілою, безпечною та масштабованою для IoT платформи корпоративного рівня
.
.
 
ВИСНОВКИ


У результаті виконання даної лабораторної роботи було розроблено клієнтську частину мобільного додатку для платформи Android на базі Kotlin, що включає зручний інтерфейс для взаємодії з користувачами системи мониторингу транспортних засобів. Створено ключові екрани, зокрема головний Dashboard з переліком ТЗ, авторизацію, реєстрацію, а також панелі адміністрування для управління користувачами та транспортними засобами.
Реалізовано спеціалізовані екрани для real-time мониторингу телеметричних даних через MQTT протокол, відображення деталей транспортного засобу з показниками температури двигуна, рівня палива та швидкості, а також систему багаторівневих алертів з можливістю відхилення критичних сповіщень. Впроваджено екран аналітики з інтеграцією Google Gemini AI для генерації персоналізованих рекомендацій по технічному обслуговуванню.
Використано Material Design 3 з кольоровою палітрою проекту, ViewModels + StateFlow для управління станом, Retrofit для взаємодії з Express.js API та Navigation Component для навігації між екранами мониторингу різних транспортних засобів. Додаток підтримує двомовність (англійська/українська) та забезпечує зручний доступ до IoT функціональності управління автопарком
.
 
ДОДАТОК А
Відеозапис

Відеозапис	презентації	результатів	лабораторної	роботи:


Хронологічний опис відеозапису:
 
ДОДАТОК Б
Програмний код


В.1 Математична обробка прикладних даних.
GitHub репозиторій: 
package com.vehiclemonitor.app.ui.vehicles

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.vehiclemonitor.app.network.NetworkModule
import com.vehiclemonitor.app.network.VehicleData
import com.vehiclemonitor.app.network.CommandRequest
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch

data class VehicleDetailState(
    val vehicleData: List<VehicleData> = emptyList(),
    val recommendations: List<String> = emptyList(),
    val isLoading: Boolean = false,
    val error: String? = null,
    val commandResult: String? = null
)

class VehicleDetailViewModel : ViewModel() {
    private val _detailState = MutableStateFlow(VehicleDetailState())
    val detailState: StateFlow<VehicleDetailState> = _detailState

    fun loadVehicleData(deviceId: String) {
        viewModelScope.launch {
            try {
                _detailState.value = _detailState.value.copy(isLoading = true, error = null)

                val response = NetworkModule.apiService.getVehicleData(deviceId)

                if (response.isSuccessful) {
                    response.body()?.let { data ->
                        _detailState.value = _detailState.value.copy(
                            vehicleData = data,
                            isLoading = false
                        )
                    }
                } else {
                    _detailState.value = _detailState.value.copy(
                        isLoading = false,
                        error = "Failed to load vehicle data: ${response.message()}"
                    )
                }
            } catch (e: Exception) {
                _detailState.value = _detailState.value.copy(
                    isLoading = false,
                    error = "Network error: ${e.message}"
                )
            }
        }
    }

    fun loadRecommendations(deviceId: String) {
        viewModelScope.launch {
            try {
                val response = NetworkModule.apiService.getRecommendations(deviceId)

                if (response.isSuccessful) {
                    response.body()?.let { recommendationsResponse ->
                        _detailState.value = _detailState.value.copy(
                            recommendations = recommendationsResponse.recommendations
                        )
                    }
                }
            } catch (e: Exception) {
                // Ignore recommendations error, not critical
                println("Failed to load recommendations: ${e.message}")
            }
        }
    }

    fun sendCommand(deviceId: String, command: String) {
        viewModelScope.launch {
            try {
                val response = NetworkModule.apiService.sendCommand(
                    deviceId, CommandRequest(command)
                )

                if (response.isSuccessful) {
                    _detailState.value = _detailState.value.copy(
                        commandResult = "Command sent successfully / Команда надіслана успішно"
                    )
                    // Clear result after showing
                    kotlinx.coroutines.delay(3000)
                    _detailState.value = _detailState.value.copy(commandResult = null)

                    // Reload data after command
                    kotlinx.coroutines.delay(2000)
                    loadVehicleData(deviceId)
                } else {
                    _detailState.value = _detailState.value.copy(
                        error = "Failed to send command: ${response.message()}"
                    )
                }
            } catch (e: Exception) {
                _detailState.value = _detailState.value.copy(
                    error = "Network error: ${e.message}"
                )
            }
        }
    }
}
